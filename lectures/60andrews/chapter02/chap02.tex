\documentclass{article}
\sloppy
%\usepackage[margin=0.5in]{geometry}
%\usepackage[landscape,margin=0.5in]{geometry}
\usepackage[landscape,top=-1in,left=0.5in,right=0.5in,bottom=0.0in]{geometry}
\usepackage{graphicx}
\usepackage{multicol}
\usepackage{overpic}
\usepackage{alltt}
\usepackage{fancyvrb}
\usepackage{natded}
\usepackage{color}

\setlength{\parindent}{0in}
\newcommand{\stm}[3]{\ensuremath{\{#1\}}\ \mbox{\tt #2}\ \ensuremath{\{#3\}}}

\newcommand{\lang}{\ensuremath{\langle}}
\newcommand{\rang}{\ensuremath{\rangle}}
%\newcommand{\myfig}[1]{\hspace{-1.5in}{\includegraphics[width=1.5\textwidth]{{#1}}}\newpage}

\newcommand{\myfig}[1]{\begin{overpic}[scale=1.5]{#1}}
\newcommand{\myfigsmall}[1]{\begin{overpic}[scale=1.25]{#1}}
\newcommand{\myfigend}{\end{overpic}\newpage}
\newcommand{\myput}[2]{\put(10,#1){$\bullet$ #2}}
\newcommand{\myputn}[2]{\put(15,#1){#2}}

\newcommand{\bi}{\begin{itemize}}
\newcommand{\ii}{\item}
\newcommand{\ei}{\end{itemize}}
\newcommand{\ti}[1]{
\mbox{~}

\vspace{1.25in}
\centerline{\bf #1}}

\newcommand{\la}{\ensuremath{\langle}}
\newcommand{\ra}{\ensuremath{\rangle}}

\newcommand{\true}{\mbox{\sc \color{blue} true}}
\newcommand{\false}{\mbox{\sc \color{red} false}}

\title{Andrews Figures, Chapter 03}
\author{Geoffrey Matthews\\
\small Western Washington University}

\RecustomVerbatimEnvironment
  {Verbatim}{Verbatim}
  {frame=single,commandchars=\\\{\}}

\begin{document}


\huge

\ti{}
\centerline{Andrews Chapter 02}
\newpage

\ti{Synchronization}

\bi
\ii Mutual exclusion.
\ii Condition synchronization.
\ei
\newpage

\ti{Semantics of concurrent programs}
\bi
\ii {\bf State:} the values of all the variables at a point in time.
\ii{\bf Atomic action:} Action which indivisibly examine or change state.
\ii{\bf History or interleaving or trace:} A particular sequence of the atomic
actions of a program.  Results in a particular sequence of states:  $s_0 \rightarrow s_1 \rightarrow s_3
...\rightarrow s_n$
\ii{\bf Critical section:} A section that cannot be interleaved with
other actions in other processes that reference the same variables.

\newpage
\ti{Properties of concurrent programs}
\ii {\bf Property:} Something which is true of every possible history
of a program.
\bi
\ii {\bf Safety properties:}  program never enters a bad state.
Example: Mutual exclusion.
\ii {\bf Liveness properties:} program eventually enters a good
state.  Example: Eventual entry into a critical section (no deadlock).
\ei
\ii {\bf Partial correctness:}  final state is correct, assuming the
program terminates.  A safety property.
\ii {\bf Termination:}  every loop and procedure call terminates.  All
histories are finite.  A liveness property
\ii {\bf Total correctness:}  partially correct and terminates.
\ei

\newpage
\ti{Demonstrating properties of concurrent programs}
\bi
\ii Testing and debugging.
\ii Operational reasoning.
\ii $m$ threads executing $n$ atomic actions each:
\ei
\[
\frac{(mn)!}{(m!)^n}
\]
\begin{multicols}{2}
\begin{verbatim}
m n
3 1 6
3 2 90
3 3 1680
3 4 34650
3 5 756756
3 6 17153136
3 7 399072960
3 8 9465511770
\end{verbatim}
\begin{verbatim}
m n
4 1 24
4 2 2520
4 3 369600
4 4 63063000
4 5 11732745024
4 6 2308743493056
4 7 472518347558400
4 8 99561092450391000
\end{verbatim}
\end{multicols}

\newpage

\ti{Formal Methods}

\vspace{2cm}

\begin{center}
  \begin{minipage}{16cm}
\hspace{1cm}  What has not changed over time is that concurrent and distributed
  programs cannot be ``hacked.''  Formal methods {\em must} be used in
  their specification and verification, making the subject an ideal
  vehicle to introduce students to formal methods.

  \hfill --- M. Ben-Ari
  \end{minipage}
  \end{center}


\newpage
\ti{Assertional reasoning}
\bi
\ii Axiomatic semantics
\ii Use {\em assertions} to characterize sets of states:
\bi
\ii All states in which the assertion is true.
\ei
\ii Atomic actions are {\em predicate transformers}.
\ii Prove that bad states can't happen.
\ii Can statically analyze programs.
\ii Very difficult to use correctly.
\ii Best to combine with testing and operational reasoning.
\ei

\newpage

\myfig{chap02/p45_find_seq.pdf}

\myfigend

\ti{Independence of parallel processes}
\bi
\ii {\bf Read set:}  variables read by a part of a program.
\ii {\bf Write set:}  variables written to by a part of a program (and
maybe read).
\ii Two parts are {\bf independent} if the write set of each part is
disjoint from both the read and write sets of the other part.
\ii Two parts are independent if both only read shared variables, or
each part reads different variables than the ones written into by the
other part.
\ii Which parts of the pattern finding program are independent?
\ei


\newpage
\myfig{chap02/p46a_find_interfere.pdf}
\myfigend
\myfig{chap02/p46b_find_nothing.pdf}
\myfigend
\myfig{chap02/p46c_find_co_inside_while.pdf}
\myfigend
\myfig{chap02/2_1.pdf}
\myfigend

\ti{Maximum of an array}
\begin{center}
Sequential:

\begin{minipage}{2in}
\begin{alltt}
int m = 0;
for [i = 0 to n-1] {
  if (a[i] > m)
    m = a[i];
}
\end{alltt}
\end{minipage}
\end{center}

\begin{multicols}{2}

{Incorrect but fast:}
\begin{verbatim}
int m = 0;
co [i = 0 to n-1] {
  if (a[i] > m)
    m = a[i];
}
\end{verbatim}

\vfill


{Correct but slow:}
\begin{alltt}
int m = 0;
co [i = 0 to n-1] \{
  \lang if (a[i] > m)
    m = a[i];\rang
\}
\end{alltt}

\columnbreak

{Pointless:}
\begin{alltt}
int m = 0;
co [i = 0 to n-1] \{
  if (a[i] > m)
    \lang m = a[i];\rang
\}
\end{alltt}

\vfill

{Correct and fast:}
\begin{alltt}
int m = 0;
co [i = 0 to n-1] \{
  if (a[i] > m)
    \lang if (a[i] > m)
      m = a[i];\rang
\}
\end{alltt}

\end{multicols}
\newpage

\ti{Atomic actions and await statements}
\begin{verbatim}
int y = 0, z = 0;
co x = y+z; // y = 1; z = 2; oc;
\end{verbatim}
\bi
\ii Final value of {\tt x} could be 0,1,2, or 3
\ii There is {\em never} a state in which {\tt y+z} is 2
\ei

\newpage
\ti{Assumptions for our machines}
\bi
\ii Values of basic types are stored in memory elements that are read
and written as atomic actions.
\ii Values are manipulated by loading into registers, operating on
them, and storing results back into memory.
\ii Each process has its own set of registers.  (Either separate
cores, dedicated registers, or a {\em context switch}.
\ii Intermediate results when a complex expression is evaluated are
stored in registers or private memory (e.g. a private stack).
\ei

\newpage
\ti{Appearance of atomicity}
\bi
\ii If evaluating expression {\tt e}, one process does not reference a
variable altered by another process, expression evaluation will appear
to be atomic.
\bi
\ii None of the values on which {\tt e} depends could change during
the evaluation
\ii No other process can see any temporary values that might be
created while the expression is evaluated
\ei
\ii If an assignment {\tt x = e} does not reference any variable
altered by another process then the assignment will appear atomic.
\ei

\newpage
\ti{At-Most-Once Property}
\bi
\ii A {\bf critical reference} in an expression is a reference to a
variable that is changed by another process.
\ii Assume a critical reference is to a simple variable.
\ii An assignment {\tt x = e} is {\bf at-most-once} if either
\bi
\ii {\tt e} contains at most one critical reference and {\tt x} is not
read by another process
\ii {\tt e} contains no critical references
\ei
\ii Such an assignment statement will appear to be atomic.
\ei

\newpage
\ti{Examples}
No critical references:
\begin{verbatim}
int x = 0, y = 0;
co x = x+1; // y = y+1; oc;
\end{verbatim}
{\tt x} and {\tt y} are both 1

\vspace{1in}

One critical reference and one lhs read by another:
\begin{verbatim}
int x = 0, y = 0;
co x = y+1; // y = y+1; oc;
\end{verbatim}
{\tt x} is 1 or 2, {\tt y } is 1

\vspace{1in}

Neither satisfies at-most-once:
\begin{verbatim}
int x = 0, y = 0;
co x = y+1; // y = x+1; oc;
\end{verbatim}
Values could be 1 and 2, 2 and 1, or even 1 and 1

\newpage
\ti{The Await Statement}

\bi
\ii {\tt <await (B) S;>}
\ii {\tt B} specifies a delay condition.
\ii {\tt S} is a sequence of statements guaranteed to terminate.
\ii Atomic actions are specified by angle brakets, {\tt <} and {\tt >}
\ii Therefore {\tt B} is guaranteed to be true when execution of {\tt
  S} begins.
\ii No internal state in {\tt S} is visible to other processes.
\ii What is this?

\centerline {\tt <await (s > 0) s = s - 1;>}

\vspace{1cm}

\ii Can we go the other way?
\ei

\newpage
\ti{Await is very powerful}
\bi
\ii Await is convenient to use.
\ii Await is expensive to implement.
\ii Mutual exclusion:

\centerline{\tt <S;>}

\ii For example:  {\tt < x = x+1; y = y+1; > }
\ii If {\tt S} is a single assignment that is at-most-once, then {\tt <S;>}
is the same as {\tt S;}
\ii Condition synchronization:

\centerline{\tt < await (B); >}

\ii Example, delay until {\tt count > 0}:

\centerline{\tt <await (count > 0);>}

\ii If {\tt B} is at-most-once, then {\tt < await (B); >} can be
implemented as:

\centerline{\tt while (not B);}
\ei

\newpage
\ti{Atomic actions}
\bi
\ii An {\bf unconditional} atomic action is one that does not contain
a delay condition {\tt B}.
\ii A {\bf conditional} atomic action is an {\tt await} statement with
a guard {\tt B}.  
\ii If {\tt B} is false, it can only become true as the result of
actions by other processes.
\ei


\newpage
\myfig{chap02/2_2.pdf}
\myfigend

\ti{Formal Logic}

\begin{center}
\begin{tabular}{cc|ccccc}
$ A $&$ B $&$\neg A$&$ A \wedge B $&$ A \vee B $&$ A \Rightarrow B $&$A\equiv B$\\\hline
$\true$&$ \true$&$ \false$&$ \true$&$\true$&$\true$&$\true$\\
$\true$&$ \false$&$ \false$&$\false$&$\true$&$\false$&$\false$\\
$\false$&$ \true$&$ \true$&$\false$&$\true$&$\true$&$\false$\\
$\false$&$ \false$&$ \true$&$\false$&$\false$&$\true$&$\true$\\
\end{tabular}
\end{center}

\newpage

\ti{Logic: axioms}
\LARGE
\newcommand{\eq}{&\equiv&}
\newcommand{\imp}{\Rightarrow}

\begin{multicols}{2}
\begin{eqnarray*}
A\land(B\lor C) \eq  (A\land B) \lor (A \land C)\\
A\lor(B\land C) \eq  (A\lor B) \land (A \lor C)
\end{eqnarray*}
\begin{eqnarray*}
\neg \neg A \eq A\\
A\lor A \eq A\\
A\lor \neg A \eq \true\\
A\lor \true \eq \true\\
A\lor \false \eq A\\
A\land \true \eq A\\
A\land \false \eq \false\\
A\land A \eq A\\
A\land \neg A \eq \false\\
A\imp \true \eq \true\\
A\imp \false \eq \neg A\\
\true\imp A \eq A\\
\false \imp A \eq \true\\
A\imp A \eq \true\\
A\imp B \eq \neg A \lor B\\
A\imp B \eq \neg B \imp \neg A\\
\neg(A\imp B) \eq A \land \neg B\\
A\land(A\lor B) \eq A\\
A\lor(A\land B) \eq A\\
A\land(\neg A \lor B) \eq A \land B\\
A \lor (\neg A \land B) \eq A \lor B\\
\neg(A\land B) \eq \neg A \lor \neg B\\
\neg(A\lor B) \eq \neg A \land \neg B
\end{eqnarray*}

\end{multicols}
\huge

\newpage
\ti{Logic: inference rules}
\begin{multicols}{2}
\bi
\ii Modus Ponens
\[
\frac{A\imp B, A}{B}
\]
\ii Modus Tollens
\[
\frac{A\imp B, \neg B}{\neg A}
\]
\ii Conjunction
\[
\frac{A,B}{A\land B}
\]
\ii Simplification
\[
\frac{A\land B}{A}
\]
\ii Addition
\[
\frac{A}{A\lor B}
\]
\ii Disjunctive syllogism
\[
\frac{A\lor B, \neg A}{B}
\]
\ii Hypothetical syllogism
\[
\frac{A\imp B, B\imp C}{A\imp C}
\]
\ii Constructive dilemma
\[
\frac{A\lor B, A\imp C, B\imp D}{C\lor D}
\]
\ii Destructive dilemma
\[
\frac{\neg C\lor \neg D, A\imp C, B\imp D}{\neg A \lor \neg B}
\]
\ei
\end{multicols}

\newpage
\ti{Proof strategies}
\bi
\ii {\bf Conditional proof:} To prove something like $X\imp Y$:
\bi
\ii Assume $X$ is true on one line of a proof.
\ii Show that $Y$ follows on some later line.
\ii Box up those lines to show that you're done.
\ei
\ii {\bf Indirect proof:}  To prove something like $X$:
\bi
\ii Assume $\neg X$ on one line of a proof.
\ii Show that a contradiction ($Z$ and $\neg Z$) shows up on later
lines.
\ii Box up those lines to show that you're done.
\ei
\ei

\newpage
\newcommand{\ind}{\hspace{1cm}}
\newcommand{\indd}{\hspace{2cm}}
\newcommand{\inddd}{\hspace{3cm}}
\newcommand{\indddd}{\hspace{4cm}}
\ti{Example conditional proof}
Prove: $P\imp (Q\imp(P\land Q))$

\[
\Jproof{
  \cablk{
    \proofline{P}{assumption for conditional proof}
    \proofline{...}{}
    \proofline{...}{}
    \proofline{Q\imp(P\land Q)}{somehow...}
  }
\proofline{P\imp (Q\imp(P\land Q))}{1 4 conditional}
}
\]

\vspace{1cm}
Now we need to find a proof of $Q\imp (P\land Q)$

\newpage
\ti{Example conditional proof}
Prove: $P\imp (Q\imp(P\land Q))$

We use a {\em   nested proof}:


\[
\Jproof{
  \cablk{
    \proofline{P}{assumption for conditional proof}
    \cablk{
      \proofline{Q}{assumption for conditional proof}
      \proofline{...}{}
      \proofline{...}{}
      \proofline{P\land Q} {somehow...}
    }
    \proofline{Q\imp(P\land Q)}{conditional proof}
  }
\proofline{P\imp (Q\imp(P\land Q))}{conditional proof}
}
\]

\vspace{1cm}

But line 5 follows immediately from lines 1 and 2 by
conjunction!   We can eliminate lines 3 and 4.


\newpage
\ti{Example conditional proof}
Prove: $P\imp (Q\imp(P\land Q))$


\[
\Jproof{
  \cablk{
    \proofline{P}{assumption for conditional proof}
    \cablk{
      \proofline{Q}{assumption for conditional proof}
      \proofline{P\land Q} {1 2 conjunction}
    }
    \proofline{Q\imp(P\land Q)}{conditional proof}
  }
\proofline{P\imp (Q\imp(P\land Q))}{conditional proof}
}
\]


\newpage
\ti{Example indirect proof}
Prove: $A\imp (B\imp A)$

\[
\Jproof{
\cablk{
  \proofline{\neg(A\imp (B\imp A))}{assumption for indirect proof}
  \proofline{...}{}
  \proofline{Z}{}
  \proofline{...}{}
  \proofline{\neg Z}{}
  }
\proofline{A\imp (B\imp A)}{indirect proof}
}\]
\bigskip

$Z$ can be anything at all, so we have more freedom with this method.

\newpage
\ti{Example indirect proof}
Prove: $A\imp (B\imp A)$

\[
\Jproof{
\cablk{
\proofline{\neg(A\imp (B\imp A))}{assumption for indirect proof}
\proofline{...}{}
\proofline{Z}{somehow}
\proofline{...}{}
\proofline{\neg Z}{ somehow }
}
\proofline{A\imp (B\imp A)}{3 5 indirect proof}
}
\]

\bigskip
Now what?  Start making deductions!

\newpage
\ti{Example indirect proof}
Prove: $A\imp (B\imp A)$

\[
\Jproof{
\cablk{
\proofline{\neg(A\imp (B\imp A))}{assumption for indirect proof}
\proofline{A \land \neg (B\imp A)}{equiv to line 1}
\proofline{A}{simplification from line 2}
\proofline{\neg (B\imp A)}{simplification from line 2}
\proofline{B\land \neg A}{equiv to line 4}
\proofline{B}{simplification from line 5}
\proofline{\neg A}{simplification from line 5}
}
\proofline{A\imp (B\imp A)}{indirect proof}
}
\]

\bigskip
Now what?

\newpage
\ti{Example indirect proof}
Prove: $A\imp (B\imp A)$

\[
\Jproof{
\cablk{
\proofline{\neg(A\imp (B\imp A))}{assumption for indirect proof}
\proofline{A \land \neg (B\imp A)}{equiv to line 1}
\proofline{A}{simplification from line 2}
\proofline{\neg (B\imp A)}{simplification from line 2}
\proofline{B\land \neg A}{equiv to line 4}
\proofline{B}{simplification from line 5}
\proofline{\neg A}{simplification from line 5}
}
\proofline{A\imp (B\imp A)}{3 7 indirect proof}
}
\]

\bigskip
Lines 3 and 7 give the contradiction.


\newpage
\ti{Example proof}
Prove: $(A\imp C) \imp (A\imp (B\lor C))$

\bigskip
Ideas?

\newpage
\ti{Example proof}
Prove: $(A\imp C) \imp (A\imp (B\lor C))$

\[
\Jproof{
\cablk{
\proofline{A\imp C}{assumption}
\proofline{...}{}
\proofline{A\imp (B\lor C)}{somehow}
}
\proofline{(A\imp C) \imp (A\imp (B\lor C))}{conditional proof}
}
\]
\bigskip
Ideas?
\newpage
\ti{Example proof}
Prove: $(A\imp C) \imp (A\imp (B\lor C))$

\[
\Jproof{
\cablk{
\proofline{A\imp C}{assumption}
  \cablk{
  \proofline{A}{assumption}
  \proofline{...}{}
  \proofline{B\lor C}{somehow}
  }
\proofline{A\imp (B\lor C)}{conditional proof}
}
\proofline{(A\imp C) \imp (A\imp (B\lor C))}{conditional proof}
}
\]
\bigskip
Ideas?
\newpage
\ti{Example proof}
Prove: $(A\imp C) \imp (A\imp (B\lor C))$

\[
\Jproof{
\cablk{
\proofline{A\imp C}{assumption}
  \cablk{
  \proofline{A}{assumption}
  \proofline{C}{modus ponens}
  \proofline{...}{}
  \proofline{B\lor C}{somehow}
  }
\proofline{A\imp (B\lor C)}{conditional proof}
}
\proofline{(A\imp C) \imp (A\imp (B\lor C))}{conditional proof}
}
\]
\bigskip
Ideas?
\newpage
\ti{Example proof}
Prove: $(A\imp C) \imp (A\imp (B\lor C))$

\[
\Jproof{
\cablk{
\proofline{A\imp C}{assumption}
  \cablk{
  \proofline{A}{assumption}
  \proofline{C}{modus ponens}
  \proofline{B\lor C}{addition}
  }
\proofline{A\imp (B\lor C)}{conditional proof}
}
\proofline{(A\imp C) \imp (A\imp (B\lor C))}{conditional proof}
}
\]


\newpage
\ti{Example proof using both conditional and indirect}
Prove: $(A\imp C) \imp (A\imp (B\lor C))$

\[
\Jproof{
\cablk{
  \proofline{A\imp C}{assumption for conditional proof}
  \cablk{
  \proofline{A}{assumption for conditional proof}
  \proofline{...}{}
  \proofline{B\lor C}{somehow}
  }
  \proofline{A\imp (B\lor C)}{conditional proof}
  }
\proofline{(A\imp C) \imp (A\imp (B\lor C))}{conditional proof}
}
\]

\bigskip
Ideas?

\newpage
\ti{Example proof using both conditional and indirect}
Prove: $(A\imp C) \imp (A\imp (B\lor C))$

\[
\Jproof{
\cablk{
  \proofline{A\imp C}{assumption for conditional proof}
  \cablk{
  \proofline{A}{assumption for conditional proof}
    \cablk{
    \proofline{\neg(B\lor C)}{assumption for indirect}
    \proofline{...}{}
    }
  \proofline{B\lor C}{indirect proof}
  }
  \proofline{A\imp (B\lor C)}{conditional proof}
  }
\proofline{(A\imp C) \imp (A\imp (B\lor C))}{conditional proof}
}
\]

\bigskip
Ideas?

\newpage
\ti{Example proof using both conditional and indirect}
Prove: $(A\imp C) \imp (A\imp (B\lor C))$

\[
\Jproof{
\cablk{
  \proofline{A\imp C}{assumption for conditional proof}
  \cablk{
  \proofline{A}{assumption for conditional proof}
    \cablk{
    \proofline{\neg(B\lor C)}{assumption for indirect}
    \proofline{\neg B \land \neg C}{equiv}
    \proofline{...}{}
    }
  \proofline{B\lor C}{indirect proof}
  }
  \proofline{A\imp (B\lor C)}{conditional proof}
  }
\proofline{(A\imp C) \imp (A\imp (B\lor C))}{conditional proof}
}
\]

\bigskip
Ideas?

\newpage
\ti{Example proof using both conditional and indirect}
Prove: $(A\imp C) \imp (A\imp (B\lor C))$

\[
\Jproof{
\cablk{
  \proofline{A\imp C}{assumption for conditional proof}
  \cablk{
  \proofline{A}{assumption for conditional proof}
    \cablk{
    \proofline{\neg(B\lor C)}{assumption for indirect}
    \proofline{\neg B \land \neg C}{equiv}
    \proofline{\neg B}{simplification}
    \proofline{\neg C}{simplification}
    \proofline{...}{}
    }
  \proofline{B\lor C}{indirect proof}
  }
  \proofline{A\imp (B\lor C)}{conditional proof}
  }
\proofline{(A\imp C) \imp (A\imp (B\lor C))}{conditional proof}
}
\]

\bigskip
Ideas?

\newpage
\ti{Example proof using both conditional and indirect}
Prove: $(A\imp C) \imp (A\imp (B\lor C))$

\[
\Jproof{
\cablk{
  \proofline{A\imp C}{assumption for conditional proof}
  \cablk{
  \proofline{A}{assumption for conditional proof}
    \cablk{
    \proofline{\neg(B\lor C)}{assumption for indirect}
    \proofline{\neg B \land \neg C}{equiv}
    \proofline{\neg B}{simplification}
    \proofline{\neg C}{simplification}
    \proofline{C}{1 2 modus ponens}
    }
  \proofline{B\lor C}{6 7 indirect proof}
  }
  \proofline{A\imp (B\lor C)}{conditional proof}
  }
\proofline{(A\imp C) \imp (A\imp (B\lor C))}{conditional proof}
}
\]

\newpage
\ti{Why we use boxes}
Prove: $(P\lor\neg Q)\imp (Q\imp P)$

\[
\Jproof{
\cablk{
\proofline{P\lor\neg Q}{assumption}
\proofline{...}{}
\proofline{P\imp (Q\imp P)}{somehow}
\proofline{...}{}
\proofline{\neg Q\imp (Q\imp P)}{somehow}
\proofline{(Q\imp P) \lor (Q\imp P)}{constructive dilemma}
\proofline{Q\imp P}{equivalence}
}
\proofline{(P\lor\neg Q)\imp (Q\imp P)}{conditional}
}\]

Ideas?

\newpage
\ti{Why we use boxes}
Prove: $(P\lor\neg Q)\imp (Q\imp P)$

\[
\Jproof{
\cablk{
\proofline{P\lor\neg Q}{assumption}
\cablk{
  \proofline{P}{assumption}
  \proofline{...}{}
  \proofline{Q\imp P}{somehow}
}
\proofline{P\imp (Q\imp P)}{conditional proof}
\cablk{
  \proofline{\neg Q}{assumption}
  \proofline{...}{}
  \proofline{Q\imp P}{somehow}
}
\proofline{\neg Q\imp (Q\imp P)}{conditional proof}
\proofline{(Q\imp P) \lor (Q\imp P)}{constructive dilemma}
\proofline{Q\imp P}{equivalence}
}
\proofline{(P\lor\neg Q)\imp (Q\imp P)}{conditional}
}\]

Ideas?


\newpage
\ti{Why we use boxes}
Prove: $(P\lor\neg Q)\imp (Q\imp P)$

\[
\Jproof{
\cablk{
\proofline{P\lor\neg Q}{assumption}
\cablk{
  \proofline{P}{assumption}
  \proofline{\neg Q \lor P}{addition}
  \proofline{Q\imp P}{equivalence}
}
\proofline{P\imp (Q\imp P)}{conditional proof}
\cablk{
  \proofline{\neg Q}{assumption}
  \proofline{\neg Q \lor P}{addition}
  \proofline{Q\imp P}{equivalence}
}
\proofline{\neg Q\imp (Q\imp P)}{conditional proof}
\proofline{(Q\imp P) \lor (Q\imp P)}{constructive dilemma}
\proofline{Q\imp P}{equivalence}
}
\proofline{(P\lor\neg Q)\imp (Q\imp P)}{conditional}
}\]

\newpage
\ti{Formal Logical Systems}
\bi
\ii A set of {\em symbols}
\ii A set of {\em formulas}
\ii A set of {\em axioms}
\ii A set of {\em inference rules}
\ei

\bigskip

To this we added proof strategies with boxes.


\newpage
\ti{Soundness and Completeness}

\bi
\ii Sound:
\[ \mbox{Theorems} \subseteq \mbox{Facts} \]
\ii Complete:
\[ \mbox{Facts} \subseteq \mbox{Theorems} \]
\bigskip
\ii{G\"odel's Incompleteness Theorem:}
\bi\ii Any logical system for arithmetic must be incomplete.\ei
\ii However, extending a logical system can be {\em relatively complete}.
\ei

\newpage
\ti{Programming Logic}
\bi
\ii We extend basic logic with a logic for programming languages: {\bf PL}.
\ii Our system for programming languages is relatively complete.
\ii We take on trust that facts about arithmetic are true.
\ei

\newpage

\ti{Axiomatic Semantics}
\[
\stm{P}{S}{Q}
\]
\bi
\ii Called a {\em triple}
\ii If $P$ is true before {\tt S} is executed, and {\tt S} terminates, then
$Q$ is true after {\tt S} executes.
\ii $P$ and $Q$ are {\em assertions}
\ii $P$ is the {\em precondition}
\ii $Q$ is the {\em postcondition}
\ei

\newpage
\ti{Logic should be sound}
\bi
\ii This should be a theorem:
\[ \stm{x=0}{x = x + 1;}{x = 1} \]
\ii This should not be a theorem:
\[ \stm{x=0}{x = x + 1;}{y = 1} \]
\ei

\newpage
\ti{Assignment Axiom}

\[
 \stm{P_{x\leftarrow e}}{x = e}{P}
\]

\bi
\ii Examples:
\[
 \stm{1 = 1}{x = 1}{x = 1}
\]
\[
 \stm{\true}{x = 1}{x = 1}
\]

\[
\stm{x+1 = 1}{x = x + 1}{x = 1}
\]
\[
\stm{x = 0}{x = x + 1}{x = 1}
\]

\[
\stm{x+ 1 = n}{x = x + 1}{x = n}
\]
\[
\stm{x = n-1}{x = x + 1}{x = n}
\]
\ei

\newpage
\myfig{chap02/2_3.pdf}
\myfigend

\newpage
\ti{Axiomatic Semantics}
{\bf Assignment Axiom:}
\[
\stm{P_{x\leftarrow t}}{x = t}{P}
\]

{\bf Inference rules:}
\bi
\ii Composition
\[
\frac{\stm{P}{S1}{R}, \stm{R}{S2}{Q}}{\stm{P}{S1;S2}{Q}}
\]

\ii Consequence
\begin{multicols}{2}
\[
\frac{P\imp R, \stm{R}{S}{Q}}{\stm{P}{S}{Q}}
\]
\[
\frac{\stm{P}{S}{T}, T\imp Q}{\stm{P}{S}{Q}}
\]
\end{multicols}

\ii If-then
\[
\frac{\stm{P\land C}{S}{Q}, P\land\neg C\imp Q}{\stm{P}{if C then
    S}{Q}}
\]
\ii If-then-else
\[
\frac{\stm{P\land C}{S1}{Q}, \stm{P\land\neg C}{S2}{Q}}{\stm{P}{if C then
    S1 else S2}{Q}}
\]

\ii While
\[
\frac{\stm{P\land C}{S}{P}}{\stm{P}{while C do S}{P\land\neg C}}
\]

\ei

\newpage
\ti{Proofs in Axiomatic Semantics}
Prove: \stm{x<5}{x = x + 1}{x < 7}


\[
\stm{P_{x\leftarrow t}}{x = t}{P}
\]

\[
\Jproof{
\proofline{\stm{x + 1 < 7}{x = x + 1}{x < 7}}{Axiom}
\cablk{
  \proofline{x<5}{Assumption}
  \proofline{x+1<6}{2, arithmetic}
  \proofline{6<7}{arithmetic}
  \proofline{x+1 < 7}{3,4, transitive}
}
\proofline{(x<5)\imp (x+1<7)}{2,5, conditional proof}
\proofline{\stm{x<5}{x = x + 1}{x < 7}}{1,6, consequence}
}
\]
\newpage
\ti{We can assume variables don't change in assertions.}
Prove: \stm{x<5}{x = x + 1}{x < 7}


\[
\stm{P_{x\leftarrow t}}{x = t}{P}
\]

\[
\Jproof{
\proofline{\stm{x + 1 < 7}{x = x + 1}{x < 7}}{Axiom}
\proofline{(x<5)\imp (x+1<7)}{arithmetic}
\proofline{\stm{x<5}{x = x + 1}{x < 7}}{1,2, consequence}
}
\]

\newpage
\ti{Proofs in Axiomatic Semantics}
Prove: \stm{\true}{if x < 0 then x = -x}{x \geq 0}

\[
\Jproof{
\proofline{\stm{-x \geq 0}{x = -x}{x \geq 0}}{Axiom}
\cablk{
  \proofline{\true \land (x < 0)}{assumption}
  \proofline{x < 0}{2, simplification}
  \proofline{-x > 0}{3, arithmetic}
  \proofline{-x \geq 0}{4, arithmetic}
}
\proofline{\true \land (x < 0)\imp (-x \geq 0)}{2,5, conditional proof}
\proofline{\stm{\true \land (x < 0)}{x = -x}{x \geq 0}}{1,6, consequence}
\cablk{
  \proofline{\true \land \neg(x < 0)}{assumption}
  \proofline{\neg(x<0)}{8, simplification}
  \proofline{x\geq 0}{9, arithmetic}
}
\proofline{\true \land \neg(x<0)\imp (x \geq 0)}{8,10, conditional proof}
\proofline{\stm{\true}{if x < 0 then x = -x}{x \geq 0}}{7,11,if-then}
}\]

\[
\frac{\stm{P\land C}{S}{Q}, P\land\neg C\imp Q}{\stm{P}{if C then
    S}{Q}}
\]

\newpage
\ti{Abbreviated Proofs in Axiomatic Semantics}
\begin{Verbatim}
\(\{\true\}\)
m = x;
\(\{m = x\}\)
if (y > m)
  m = y;
\(\{(m = x \land m \geq y) \lor (m = y \land m > x)\}\)
\end{Verbatim}


Assumes you can prove both

\begin{enumerate}
\item
{\stm{\true}{m = x}{m = x}}
\item
{\stm{m = x}{if (y > m) m = y;}{(m = x \land m \geq y) \lor (m = y \land m > x)}}
\end{enumerate}
Use an axiom for the first and if-then for the second:
\[
\frac{\stm{P\land C}{S}{Q}, P\land\neg C\imp Q}{\stm{P}{if C then
    S}{Q}}
\]

\newpage
\ti{Proof of second part}

Prove: \stm{m = x}{if (y > m) m = y;}{(m = x \land m \geq y) \lor (m = y \land m > x)}

\[
\frac{\stm{P\land C}{S}{Q}, P\land\neg C\imp Q}{\stm{P}{if C then
    S}{Q}}
\]
{\LARGE
\[
\Jproof{
\proofline{...}{}
\proofline{\stm{m=x\land y>m}{m = y}{(m = x \land m \geq y) \lor (m = y \land m > x)}}{}
\proofline{...}{}
\proofline{[m=x\land \neg(y>m)]\imp [(m = x \land m \geq y) \lor (m = y \land m > x)]}{}
\proofline{\stm{m = x}{if (y > m) m = y;}{(m = x \land m \geq y) \lor (m = y \land m > x)}}{2, 4, if-then}
}\]
}

\newpage
\ti{Proof of second part}

Prove: \stm{m = x}{if (y > m) m = y;}{(m = x \land m \geq y) \lor (m = y \land m > x)}

\[
\frac{\stm{P\land C}{S}{Q}, P\land\neg C\imp Q}{\stm{P}{if C then
    S}{Q}}
\]
{\LARGE
\[
\Jproof{
\proofline{\stm{(y = x \land y \geq y) \lor (y = y \land y > x)}{m = y}{(m = x \land m \geq y) \lor (m = y \land m > x)}}{AA}
\proofline{...}{}
\proofline{\stm{m=x\land y>m}{m = y}{(m = x \land m \geq y) \lor (m = y \land m > x)}}{}
\proofline{...}{}
\proofline{[m=x\land \neg(y>m)]\imp [(m = x \land m \geq y) \lor (m = y \land m > x)]}{}
\proofline{\stm{m = x}{if (y > m) m = y;}{(m = x \land m \geq y) \lor (m = y \land m > x)}}{if-then}
}\]
}

\bi
\ii What else do we need?
\ei

\newpage
\ti{Proof of second part}

Prove: \stm{m = x}{if (y > m) m = y;}{(m = x \land m \geq y) \lor (m = y \land m > x)}

\[
\frac{\stm{P\land C}{S}{Q}, P\land\neg C\imp Q}{\stm{P}{if C then
    S}{Q}}
\]
{\LARGE
\[
\Jproof{
\proofline{\stm{(y = x \land y \geq y) \lor (y = y \land y > x)}{m = y}{(m = x \land m \geq y) \lor (m = y \land m > x)}}{AA}
\proofline{...}{}
\proofline{(m=x\land y>m)\imp(y = x \land y \geq y) \lor (y = y \land y > x)}{logic}
\proofline{\stm{m=x\land y>m}{m = y}{(m = x \land m \geq y) \lor (m = y \land m > x)}}{consequence}
\proofline{...}{}
\proofline{[m=x\land \neg(y>m)]\imp [(m = x \land m \geq y) \lor (m = y \land m > x)]}{logic}
\proofline{\stm{m = x}{if (y > m) m = y;}{(m = x \land m \geq y) \lor (m = y \land m > x)}}{if-then}
}\]
}


\newpage
\ti{Proof of second part, alternate}

Prove: \stm{m = x}{if (y > m) m = y;}{(m = x \land m \geq y) \lor (m = y \land m > x)}

\[
\frac{\stm{P\land C}{S}{Q}, P\land\neg C\imp Q}{\stm{P}{if C then
    S}{Q}}
\]
{\LARGE
\[
\Jproof{
\proofline{\stm{(y = y \land y > x)}{m = y}{(m = y \land m > x)}}{AA}
\proofline{...}{}
\proofline{\stm{m=x\land y>m}{m = y}{(m = x \land m \geq y) \lor (m = y \land m > x)}}{}
\proofline{...}{}
\proofline{[m=x\land \neg(y>m)]\imp [(m = x \land m \geq y) \lor (m = y \land m > x)]}{}
\proofline{\stm{m = x}{if (y > m) m = y;}{(m = x \land m \geq y) \lor (m = y \land m > x)}}{if-then}
}\]
}

\bi
\ii Need to prove two more things.  What are they?
\ei

\newpage
\ti{Proof of second part, alternate}

Prove: \stm{m = x}{if (y > m) m = y;}{(m = x \land m \geq y) \lor (m = y \land m > x)}

\[
\frac{\stm{P\land C}{S}{Q}, P\land\neg C\imp Q}{\stm{P}{if C then
    S}{Q}}
\]
{\LARGE
\[
\Jproof{
\proofline{\stm{(y = y \land y > x)}{m = y}{(m = y \land m > x)}}{AA}
\proofline{(m=x\land y>m)\imp(y=y\land y> x)}{logic}
\proofline{(m = y \land m > x)\imp(m = x \land m \geq y) \lor (m = y \land m > x)}{logic}
\proofline{\stm{m=x\land y>m}{m = y}{(m = x \land m \geq y) \lor (m = y \land m > x)}}{Consequence}
\proofline{[m=x\land \neg(y>m)]\imp [(m = x \land m \geq y) \lor (m = y \land m > x)]}{logic}
\proofline{\stm{m = x}{if (y > m) m = y;}{(m = x \land m \geq y) \lor (m = y \land m > x)}}{if-then}
}\]
}

\newpage
\ti{Proofs in Axiomatic Semantics}
\begin{Verbatim}
\(\{\true\}\)
i = 1;
\(\{i = 1 \land \forall j: 1 \leq j < i: a[j] \not= x)\}\)
while (a[i] != x)
  \(\{(\forall j: 1 <= j < i: a[j] \not= x)\}\)
  i = i+1;
\(\{(\forall j: 1 \leq j < i: a[j] \not= x) \land a[i] = x\}\)
\end{Verbatim}

\[
\frac{\stm{P\land C}{S}{P}}{\stm{P}{while C do S}{P\land\neg C}}
\]


\newpage
\ti{Proofs in Axiomatic Semantics}
\begin{Verbatim}
\(\{(a>0)\land(b\geq 0)\}\)
i = 0;
p = 1;
\(\{P\} = \{(p = a^i) \land (i\leq b)\}\)
while i < b do
  p = p*a;
  i = i+1;
\(\{(P\land \neg C)\} = \{(p = a^i) \land (i\leq b) \land \neg(i<b)\}\)
\(\{p = a^b\}\)
\end{Verbatim}

\[
\frac{\stm{P\land C}{S}{P}}{\stm{P}{while C do S}{P\land\neg C}}
\]

\newpage

\myfig{chap02/p63_await_co_rules.pdf}
\myfigend

\ti{Sematics of Concurrent Execution}
\bi
\ii Await rule
\[
\frac{\stm{P\land B}{S}{Q}}{\stm{P}{\la await (B) S;\ra}{Q}}
\]
\ii Co rule
\[
\frac{\stm{P_i}{Si}{Q_i}\mbox{\ are interference free}}
     {\stm{P_1\land ... \land P_n}{co S1; // ... // Sn; oc}{Q_1\land ... \land Q_n}}
\]

\bigskip
\ii One process {\bf interferes} with another if it executes an
assignment that invalidates an assertion in the other process. 
\ei

\newpage
\ti{Co example}
\bi
\ii
\begin{Verbatim}
\(\{x = 0\}\)
co \la x = x+1;\ra // \la x = x+2;\ra oc
\(\{x = 3\}\)
\end{Verbatim}
\ii Neither process can assume that $x=0$ when they start.
\ii But the following can be assumed:
\ii
\begin{Verbatim}
\(\{x = 0\}\)
co 
  \(\{x = 0 \lor x = 2\}\)
  \la x = x + 1; \ra
  \(\{x = 1 \lor x = 3\}\)
//
  \(\{x = 0 \lor x = 1\}\)
  \la x = x + 2; \ra
  \(\{x = 2 \lor x = 3\}\)
oc
\(\{ x = 3 \}\)
\end{Verbatim}
\ei

\newpage
\ti{Definition of Noninterference}
\bi
\ii An {\bf assignment action} is an assignment statement or an {\tt
  await} statement that contains one or more assignments.
\ii A {\bf critical assertion} is a precondition or postcondition that
is not within an {\tt await} statement.
\ii Rename all local variables in all processes so that no two
processes have the same local variable names.
\ii Let {\tt a} be an assignment action in one process and let $pre(a)$ be its precondition.  Let $C$ be a critical assertion in
another process.  Then {\tt a} {\bf does not interfere} with $C$ if the
following is a theorem:
\centerline{\stm{C\land pre(a)}{a}{C}}
\ii $C$ is {\em invariant} with respect to assignment {\tt a}

\ei

\newpage

\ti{Example of noninterference}
\bi
\ii
\begin{Verbatim}
\(\{x = 0\}\)
co 
  \(\{x = 0 \lor x = 2\}\)
  \la x = x + 1; \ra
  \(\{x = 1 \lor x = 3\}\)
//
  \(\{x = 0 \lor x = 1\}\)
  \la x = x + 2; \ra
  \(\{x = 2 \lor x = 3\}\)
oc
\(\{ x = 3 \}\)
\end{Verbatim}
\ii The precondition of the first process is a critical assertion.
\ii It is not interfered with by the second process because:
\ii
\begin{Verbatim}
\(\{(x = 0 \lor x = 2) \land (x = 0\lor x = 1)\}\)
x = x+2;
\(\{x = 0 \lor x = 2\}\)
\end{Verbatim}
\ei
\newpage

\ti{Techniques for avoiding interference:  disjoint variables}
\bi
\ii {\bf Read set:} set of variables read by a process.
\ii {\bf Write set:} set of variables written to by a process.
\ii {\bf Reference set:} set of variables that appear in the
assertions of a proof of that process.  
\ii Reference set is usually the union of the read and write sets.
\ii If the write set of one process is disjoint from the reference set
of a second, and vice versa, the two processes cannot interfere.
\ii Example:
\ii {\tt co x = x+1; // y = y+1; oc}
\ii Both of the following are theorems:
\ii \stm{x = 0}{x = x + 1;}{x = 1}
\ii \stm{y = 0}{y = y + 1;}{y = 1}
\ii Each statement contains one assignment and two assertions, so
there are four noninterference theorems to prove, but they are all
trivial. 
\ei

\newpage

\ti{Techniques for avoiding interference: weakened assertions}
\bi
\ii A {\bf weakened assertion} is one that admits more program states
than another assertion that might be true of a process in isolation.
\ii Example:
\ii
\begin{Verbatim}
\(\{x = 0\}\)
co 
  \(\{x = 0 \lor x = 2\}\)
  \la x = x + 1; \ra
  \(\{x = 1 \lor x = 3\}\)
//
  \(\{x = 0 \lor x = 1\}\)
  \la x = x + 2; \ra
  \(\{x = 2 \lor x = 3\}\)
oc
\(\{ x = 3 \}\)
\end{Verbatim}
\ei



\newpage
\ti {Techniques for avoiding interference: global invariants}
\bi
\ii If $I$ is a predicate that references global variables, then $I$
is a {\bf global invariant} with respect to a set of processes if:
\begin{enumerate}
\ii $I$ is true when the processes begin, and
\ii $I$ is preserved by every assignment action.
\end{enumerate}
\bigskip
\ii Suppose $I$ is a global invariant, and every critical assertion
has the form $I \land L$, where $L$ is only about local variables,
then all processes will be interference free.
\ii Checking this is a {\em linear} process, as opposed to the {\em
  exponential } number of program histories.
\ei

\newpage
\ti {Techniques for avoiding interference: synchronization}
\bi
\ii Statements within {\tt await} statements appear indivisible to
other processes.
\ii Hence we can ignore them when considering interference, and
consider only {\em entire} sequences.
\ii For example, in the statement\\
\centerline{\tt \la x = x+1; y = y+1; \ra}
we don't have to consider each statement by itself.
\ei
\newpage
\ti {Techniques for avoiding interference: synchronization}
\bi
\ii Consider the following:
\begin{verbatim}
co P1: ... a; ...
// P2: ... S1; {C} S2; ...
oc
\end{verbatim}
\ii{\tt a} might interfere with {\tt C}
\ii There are two ways to ``hide'' {\tt C} from {\tt a}
\ii \begin{verbatim}
< S1 ; S2 >
\end{verbatim}
\ii \begin{verbatim}
< await (!C or B) a; >
\end{verbatim}
where {\tt B} is a set of predicates such that executing {\tt a} will make
{\tt C} true.
\ei

\newpage

\myfig{chap02/2_2.pdf}
\myfigend

\myfigsmall{chap02/2_4.pdf}
\myfigend

\ti{Example illustrates all four techniques}
\bi
\ii Many statements and parts are disjoint.
\ii Weakened assertions, e.g. {\tt buf = A[p-1]} but only when \verb|p = c+1|
\ii Global invariant {\em PC}
\ii Synchronization using {\tt await}
\ei

\newpage
\ti{Safety and Liveness Properties}

\bi
\ii {\bf Safety:}  nothing bad ever happens.
\bi 
\ii Final state is correct.
\ii Mutual exclusion.
\ii No deadlock.
\ei
\ii {\bf Liveness:}  something good eventually happens.
\bi 
\ii Program terminates 
\ii Process eventually enters critical section.
\ii A request for service will eventually be honored.
\ii A message will reach its destination.
\ei
\ei

\newpage
\ti{Proving Safety Properties}
\bi
\ii Show that {\em BAD} is false in every state.
\ii Show that {\em GOOD} is true in every state.
\begin{description}
\ii {\em GOOD} = $\neg${\em BAD}
\ii {\em GOOD} will be an invariant.
\end{description}
\ei



\newpage
\ti{Proving Safety Properties: exclusion of configurations}
\begin{Verbatim}
co # process 1
  ...;  \{ pre(S1) \} S1; ...
// # process 2
  ...;  \{ pre(S2) \} S2; ...
oc
\end{Verbatim}
\bi
\ii Suppose the preconditions do not interfere.
\ii Suppose {\tt pre(S1) $\land$  pre(S2) = false}.
\ii Then the two processes cannot be at these statements at the same time!
\ii {\tt false} means that the program is {\em never} in this state.
\ii In the array copy example, both processes cannot simultaneously be
delayed  in their {\tt await} statements. 
\ei

\newpage

\myfigsmall{chap02/2_4.pdf}
\put(53,75){$PC\land (p < n) \land (p \not= c)$}
\put(55,72){(when delayed)}
\put(53,53){$IC\land (c < n) \land (p \leq c)$}
\put(55,50){(when delayed)}
\myfigend

\ti{Scheduling and Fairness}
\bi
\ii {\bf Fairness:}  each process gets a chance to proceed.
\ii An atomic action is {\bf eligible} if it is the next one in the
process that could be executed.
\ii A {\bf scheduling policy} determines which eligible action will be
executed next.
\ei

\newpage
\ti{Scheduling and Fairness}
\bi
\ii
\begin{Verbatim}
bool continue = true;
co while (continue);
// continue = false;
oc
\end{Verbatim}

\ii If the first process always goes first, this program will never
terminate. 
\ei

\newpage

\ti{Fairness}

\bi 
\ii {\bf Unconditional fairness:}  if every unconditional atomic
action that is eligible is executed eventually.
\ii {\bf Weak fairness:} 
\begin{enumerate}
\ii it is unconditionally fair, and
\ii every conditional atomic action  that is eligible is executed
eventually, assuming that its condition becomes true and then remains
true until it is seen by the process executing the conditional atomic
action.
\end{enumerate}
\ii In other words, assuming that
\begin{description}
\item (a) if {\tt \la await (B) S;\ra} is
eligible and {\tt B} becomes true then {\tt B} remains true 
until {\tt S}, then
\item (b) {\tt \la await (B) S;\ra} will be executed eventually.  
\end{description}
\ii Round-robin and time slicing are weakly fair.  \ii
Not sufficient to guarantee that any eligible {\tt await} statement
eventually executes.  \ei

\newpage
\ti{Fairness}
\bi
\ii {\bf Strong fairness:}  
\begin{enumerate}
\ii it is unconditionally fair, and
\ii every conditional atomic action that is eligible is executed
eventually, assuming that its condition is infinitely often true.
\end{enumerate}
\ii Such a scheduling policy cannot happen to select an action only
when the condition is false.
\ei

\newpage
\ti{Difference between strong and weak fairness}
\begin{Verbatim}
bool continue = true, try = false;

co while (continue) \{try = true; try = false;\}
// \la await (try) continue = false; \ra
oc
\end{Verbatim}
\bi
\ii With strong fairness, this program will eventually terminate.
\ii With weak fairness, this program might not terminate, even though
{\tt try} becomes true infinitely often.
\ii It is impossible to devise a scheduler that is both practical and
strongly fair.
\newpage

\ti{Fairness in the array copy example}

\ii The example is deadlock free, even with weak fairness:
\bi
\ii When one process makes the delay condition of the other true, it
stays true until after the other process continues.
\ii Each {\tt await} statement has the form {\tt \la await(B);\ra},
and {\tt B} refers to only one variable altered by the other process.
\ii Both {\tt await} statements could be implemented with busy loops:

\centerline{{\tt \la await (p = c)\ra} $\equiv$ {\tt while (p != c)}}

\ei
\ii This program will terminate only on unconditional fairness, since
there are no more conditional atomic actions.
\ei

\myfigsmall{chap02/2_4.pdf}
\myfigend

\ti{Livelock}
\bi
\ii If all busy waiting loops spin forever, the program is said to
suffer {\bf livelock}.
\ii The program is alive, but the processes are not going anywhere.
\ii Like two people passing each other in a hallway, each constantly
moving to the other side.
\ii Absence of livelock is a safety property.
\ei


\end{document}
